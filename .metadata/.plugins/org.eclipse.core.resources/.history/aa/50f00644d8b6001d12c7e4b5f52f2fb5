/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * Define the memory addresses to be worked with
 */
// SRAM
#define SRAM_START 0x20000000U					// SRAM start address
#define SRAM_SIZE  (1024 * 128)					// Length of available SRAM
#define SRAM_END (SRAM_START + SRAM_SIZE)		// End of SRAM address space

#define STACK_START SRAM_END
// MSP
#define STACK_MSP_START STACK_START
#define STACK_MSP_END (STACK_START - 512)

// PSP
#define PSP_START STACK_MSP_END
#define PSP_END (PSP_START - 512)

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/**
 * Function to set PSP as the current stack pointer
 */
__attribute__((naked)) void change_sp_to_psp(){

	asm volatile(".equ SRAM_END, (0x20000000U + (1024 * 128))");	// Define the PSP Start address
	asm volatile(".equ PSP_START, (SRAM_END-512)");					// Define  the PSP base address
	asm volatile("LDR R0, PSP_START");								// Load register with address for PSP start
	asm volatile("MSR PSP, R0");									// initialize the PSP to it's starting address

	// Set the SPSEL bit in the control register
	asm volatile("MOV R0, #0x02");									// Load R0 with the mask
	asm volatile("MSR CONTROL, R0");								// Set the control bit
}

/**
 * Function to generate an interrupt
 */
void generate_SVC_interrupt()
{
	__asm volatile("SVC #0x02");
}


// Define a function to handle the SVC interrupt
void SVC_Handler(){
	uint32_t control = 0;
	uint32_t addr = 0;
	asm volatile("MRS %0, CONTROL" : "=r"(control));				//Read the value in the control bit
	asm volatile("MRS %0, PSP" : "=r"(addr));						// Read the address of the PSP register
//	printf("The control bit is set to %x\nWhile the PSP's address is %x\n", control, addr);
}

int main(void)
{
	// Switch to PSP
	change_sp_to_psp();
	// Generate the interrupt
	generate_SVC_interrupt();
    /* Loop forever */
	for(;;);
}
