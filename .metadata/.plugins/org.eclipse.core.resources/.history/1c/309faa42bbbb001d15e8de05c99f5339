/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

/** -------------------------------------------------------------- **/
/**-------------------Task Handler Declarations ----------------- **/
/** -------------------------------------------------------------- **/
// Task Handlers
void task_1_handler(void);
void task_2_handler(void);
void task_3_handler(void);
void task_4_handler(void);



/** -------------------------------------------------------------- **/
/**------------------- Global variables ----------------- **/
/** -------------------------------------------------------------- **/

// task structs
task_t tasks[MAX_TASKS];


//// PSP value of tasks
//uint32_t psp_of_tasks[MAX_TASKS] = {TASK_1_START,
//									TASK_2_START,
//									TASK_3_START,
//									TASK_4_START};
//
//// Address of task handlers
//uint32_t task_handlers[MAX_TASKS];

// Index of current task
uint8_t volatile curr_task = 0;


/** -------------------------------------------------------------- **/
/** ---------------- Helper Function Definitions ----------------- **/
/** -------------------------------------------------------------- **/
uint32_t get_curr_task_psp();
void update_task();

/** -------------------------------------------------------------- **/
/**------------------- Configuration/Setup Functions ----------------- **/
/** -------------------------------------------------------------- **/

// Enable Processor Faults
void enable_interrupts(){
	SHCSR |= (1 << 18);		// Usage Faults
	SHCSR |= (1 << 17);		// Bus faults
	SHCSR |= (1 << 16);		// Mem faults
}

/**
 * Function to define the count down time for the scheduler
 * Calculates the count number (N) needed for
 * the specified time and sets the SRVR to (N-1)
 *
 * Param(s):
 * 	time_ms: Frequency of the scheduler's exception in milli-seconds
 *
 * Return:
 * 	Void
 */
void set_scheduler_time(uint32_t time_ms){
	uint32_t reload_val = 0;
	reload_val = (uint32_t) ( (time_ms/(CPU_PERIOD*1000) ) -1 );
	// Clear SYST_RVR
	SYST_RVR &= ~(0x00FFFFFF);
	// Set SYST_RVR
	SYST_RVR |= reload_val;

	// Enable the Systick timer
	// Clock source = internal (1)
	// Count down to zero triggers interrupt (1)
	// Enable sys-tick interrupt (1)
	SYST_CSR |= 0x7;
}


// initialize task handlers
void init_task_handler_addrs(){
	task_handlers[0] = (uint32_t) task_1_handler;
	task_handlers[1] = (uint32_t) task_2_handler;
	task_handlers[2] = (uint32_t) task_3_handler;
	task_handlers[3] = (uint32_t) task_4_handler;
}


// Function to initialize the scheduler task
__attribute__((naked)) void stack_init(uint32_t top_of_scheduler_stack){
	// Set MSP to point at the top of the scheduler stack
	asm volatile("MSR MSP, %0" : : "r"(top_of_scheduler_stack));
	asm volatile("BX LR");
}


/**
 * Function to instantiate the task's stacks with dummy values
 */
void init_tasks(void){
	// Define a variable for holding the current task's PSP
	uint32_t* curr_psp = NULL;

	/**
	 * Create dummy registers of tasks 2 - 4
	 * Don't initialize for task 1, since stcking is done after the first sys tick exception
	 */
	for(uint8_t i = 1; i < MAX_TASKS; i++){
		// Get the current task's psp location
		curr_psp = (uint32_t*) psp_of_tasks[i];

		// initialize the xPSR
		curr_psp--;
		*curr_psp = (uint32_t) 0x01000000;
		// PC return address
		curr_psp--;
		*curr_psp = (uint32_t) task_handlers[i];
		// Set the LR EXEC_RETURN ADDRESS
		curr_psp--;
		*curr_psp = 0xFFFFFFFD;		// use PSP after return

		// Set the value of the general purpose registers
		for(uint8_t reg = 0; reg < 13; reg++){
			curr_psp--;
			*curr_psp = 0;		// Set to zero
		}
		// Store the value of PSP  after the stack initialization
		psp_of_tasks[i] = (uint32_t) curr_psp;
	}

}

__attribute__((naked)) void switch_to_PSP(){
	// initialize PSP with the value of the task 1 at the start of the program
	// Store the value of the LR register
	asm volatile("PUSH {LR}");
	// Branch to function to retrieve the address of task1's PSP
	asm volatile("BL get_curr_task_psp");
	// Load the value into the PSP register
	asm volatile("MSR PSP, R0");
	// Retrieve the LR's pushed value
	asm volatile("POP {LR}");

	// Change the SP from MSP to PSP
	asm volatile("MOV R0, #0x2");
	asm volatile("MSR CONTROL, R0");

	// Return back to caller
	asm volatile("BX LR");
}

/** -------------------------------------------------------------- **/
/** ------------------------ Main Function ----------------------- **/
/** -------------------------------------------------------------- **/


int main(void)
{
	// DONE USING MSP
	// instantiate interrupts
	enable_interrupts();
	// initialize the scheduler stack pointer
	stack_init(SCHED_TASK_START);
	// Initialize task handler addresses
	init_task_handler_addrs();
	// initialize the task's stacks with dummy values for their first run
	init_tasks();
	// Set the scheduler time for 1 ms
	set_scheduler_time(1);


	// DONE USING PSP
	// Switch the SP to PSP
	switch_to_PSP();

	// Start operation
	task_1_handler();

    /* Loop forever */
	for(;;);
}

/** -------------------------------------------------------------- **/
/**-------------------Task Function Definitions ----------------- **/
/** -------------------------------------------------------------- **/

void idle_task(){
	while(1);
}

void task_1_handler(void){
	while(1){
		printf("In Task 1...\n");
	}
}


void task_2_handler(void){
	while(1)
		printf("In Task 2...\n");
}


void task_3_handler(void){
	while(1)
		printf("In Task 3...\n");
}


void task_4_handler(void){
	while(1)
		printf("In Task 4...\n");
}

/** -------------------------------------------------------------- **/
/** ------------------------ Exception Handlers ------------------ **/
/** -------------------------------------------------------------- **/




/** -------------------------------------------------------------- **/
/** ------------------------ Helper Function Declaration ----------------------- **/
/** -------------------------------------------------------------- **/
uint32_t get_curr_task_psp(){
	return psp_of_tasks[curr_task];
}

void update_task(){
	curr_task = (curr_task+1) % MAX_TASKS;
}

// Sys-tick handler function:
// This functoin performs the context switch
// Takes saves R[4-11] of of the current running task
// Pops R[4:11]of the next task and then exits the exception
__attribute__((naked)) void SysTick_Handler(){
	// Get the address of the current task's PSP
	asm volatile("MRS R0, PSP");
	// Push registers R4 - R11
	asm volatile("STMDB R0!, {R4-R11} ");
	// Save the value of the PSP
	asm volatile("MOV %0, R0" : "=r"(psp_of_tasks[curr_task]));

	/* Update to the next task */

	// Push the LR register
	asm volatile("PUSH {LR}");
	// Update task reference
	asm volatile("BL update_task");
	// Get the current running task
	asm volatile("BL get_curr_task_psp");
	// Load R4-R11 of the new task
	asm volatile("LDMIA R0!, {R4-R11}");
	// Load the address onto the PSP register
	asm volatile("MSR PSP, R0");
	// POP back the LR register
	asm volatile("POP {LR}");
	// Branch back to thread mode
	asm volatile("BX LR");
}
