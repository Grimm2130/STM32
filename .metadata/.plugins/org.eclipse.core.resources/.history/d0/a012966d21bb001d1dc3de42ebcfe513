/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

/** -------------------------------------------------------------- **/
/**------------------- Configuration/Setup Functions ----------------- **/
/** -------------------------------------------------------------- **/

/**
 * Function to define the count down time for the scheduler
 * Calculates the count number (N) needed for
 * the specified time and sets the SRVR to (N-1)
 *
 * Param(s):
 * 	time_ms: Frequency of the scheduler's exception in milli-seconds
 *
 * Return:
 * 	Void
 */
void set_scheduler_time(uint32_t time_ms){
	uint32_t reload_val = 0;
	reload_val = (uint32_t) ( (time_ms/(CPU_PERIOD*1000) ) -1 );
	// Clear SYST_RVR
	SYST_RVR &= ~(0x00FFFFFF);
	// Set SYST_RVR
	SYST_RVR |= reload_val;

	// Enable the Systick timer
	// Clock source = internal (1)
	// Count down to zero triggers interrupt (1)
	// Enable sys-tick interrupt (1)
	SYST_CSR |= 0x7;
}


// initialize task handlers
void init_task_handler_addrs(){
	task_handlers[0] = task_1_handler;
	task_handlers[1] = task_2_handler;
	task_handlers[2] = task_3_handler;
	task_handlers[3] = task_4_handler;
}


// Function to initialize the scheduler task
__attribute__((naked)) void stack_init(uint32_t top_of_scheduler_stack){
	// Set MSP to point at the top of the scheduler stack
	asm volatile("MSR MSP, %0" : : "r"(top_of_scheduler_stack));
	asm volatile("BX LR");
}


/**
 * Function to instantiate the task's stacks with dummy values
 */
void init_tasks(void){
	// Define a variable for holding the current task's PSP
	uint32_t* curr_psp = NULL;
	for(uint8_t i = 0; i < MAX_TASKS; i++){
		// Get the current task's psp location
		curr_psp = (uint32_t*) psp_of_tasks[i];

		// initialize the xPSR
		curr_psp--;
		*curr_psp = (uint32_t) 0x01000000;
		// PC return address
		curr_psp--;
		*curr_psp = (uint32_t) task_handlers[curr_task];
		// Set the LR EXEC_RETURN ADDRESS
		curr_psp--;
		*curr_psp = 0xFFFFFFFD;		// use PSP after return
		// Set the value of the general purpose registers
		for(uint8_t reg = 0; reg < 13; reg++){
			curr_psp--;
			*curr_psp = 0;		// Set to zero
		}
	}

}

__attribute__((naked)) void switch_to_PSP(){
	// Get te
	asm volatile("MRS R0, CONTROL");

}

/** -------------------------------------------------------------- **/
/**-------------------Task Handler Declarations ----------------- **/
/** -------------------------------------------------------------- **/
// Task Handlers
void task_1_handler(void);
void task_2_handler(void);
void task_3_handler(void);
void task_4_handler(void);


/** -------------------------------------------------------------- **/
/** ------------------------ Main Function ----------------------- **/
/** -------------------------------------------------------------- **/


int main(void)
{
	// DONE USING MSP
	// initialize the scheduler stack pointer
	stack_init(SCHED_TASK_START);
	// Initialize task handler addresses
	init_task_handler_addrs();
	// initialize the task's stacks with dummy values for their first run
	init_tasks();
	// Set the scheduler time for 1 ms
	set_scheduler_time(1);


	// DONE USING PSP
	// Switch the SP to PSP

    /* Loop forever */
	for(;;);
}

/** -------------------------------------------------------------- **/
/**-------------------Task Function Definitions ----------------- **/
/** -------------------------------------------------------------- **/

void task_1_handler(void){
	while(1){
		printf("In Task 1...\n");
	}
}


void task_2_handler(void){
	while(1)
		printf("In Task 2...\n");
}


void task_3_handler(void){
	while(1)
		printf("In Task 3...\n");
}


void task_4_handler(void){
	while(1)
		printf("In Task 4...\n");
}


//__attribute__((naked)) void SysTick_Handler(){
//	// We know that sys tick exception has pushed
//	// registers R[0:3],
//	// LR,
//	// PC return address for the previous task
//	// And xPSR (status) register for the previous task
//
//	// For for this step we do the following
//	// Push the remaining registers on to the stack PSP
//
//}
