/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// Base address for the System Handler Control and State Register (Configurable)
#define SHCSR (* (uint32_t volatile*) 0xE000ED24)

// Bit locations for the Faults exception enable

#define MEM 16					// MEM
#define USAGE 18				// USAGE

/** Since the HARD faults are always enabled, there's no need to configure it **/

/**
 * Addresses System Interrupt Configuration registers
 */

void enable_usage_fault(){
	SHCSR |= (1 << USAGE);
}

void enable_mem_fault(){
	SHCSR |= (1 << MEM);
}

/**
 * A Function to run an undefined function to trigger the usage fault
 */
void trigger_usage_1(){
	// Define the address of a function
	uint32_t* inst = (uint32_t*) 0x20001001;			// last bit should be one to ensure thumb instruction is being ran

	//Define the instruction to be ran at that location
	*inst = 0xFFFFFFFF;

	// Define a function pointer to that location
	void (*some_function) (void)= (void*) inst;

	// Dereference/call the function
	some_function();
}

__attribute__((naked)) void trigger_usage_2(){
	asm volatile("MOV R0, #0");
	asm volatile("MOV R1, #2");
	asm volatile("UDIV R1, R1, R0");
}

void trigger_MEM_fault(){

	// Load a function into the peripheral region
	uint32_t* addr = (uint32_t*) 0x40000020;
	*addr = 0x4FF00200;

	void (*some_func) (void) = (void*) addr;

	some_func();
}

//__attribute__((naked)) void trigger_SVC(){
//		asm volatile ("SVC #2");
//}

int main(void)
{
	// enable the mem fault
	enable_mem_fault();

	// trigger the usage fault
	trigger_usage_2();

    /* Loop forever */
	for(;;);
}

void UsageFault_Handler(){
	printf("In usage fault handler\n");
	// Get the address of the stack pointer
	uint32_t* sp_addr = NULL;
	asm volatile("MRS %0, MSP" : "=r"(sp_addr));
	for(uint8_t i = 0; i < 8; i++){
		printf("At %p, the value in memory is: %lx", sp_addr, (*sp_addr));
		sp_addr++;
	}
}

void MemManage_Handler(){
	printf("In Memory fault manager\n");
}

//void SVC_Handler(){
//	printf("In SVC handler\n");
//	printf("Calling SVC instruction again\n");
//
//	asm volatile ("SVC #x01");
//}

void HardFault_Handler(){
	printf("In Hard fault handler\n");
	while(1);
}
